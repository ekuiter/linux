<title>DVB Frontend API</title>

<para>The DVB frontend API was designed to support three types of delivery systems:</para>
<itemizedlist>
    <listitem>Terrestrial systems: DVB-T, DVB-T2, ATSC, ATSC M/H, ISDB-T, DVB-H, DTMB, CMMB</listitem>
    <listitem>Cable systems: DVB-C Annex A/C, ClearQAM (DVB-C Annex B), ISDB-C</listitem>
    <listitem>Satellital systems: DVB-S, DVB-S2, DVB Turbo, ISDB-S, DSS</listitem>
</itemizedlist>
<para>The DVB frontend controls several sub-devices including:</para>
<itemizedlist>
    <listitem>Tuner</listitem>,
    <listitem>Digital TV demodulator</listitem>
    <listitem>Low noise amplifier (LNA)</listitem>
    <listitem>Satellite Equipment Control (SEC) hardware (only for Satellite).</listitem>
</itemizedlist>
<para>The frontend can be accessed through
    <emphasis role="bold">/dev/dvb/adapter?/frontend?</emphasis>. Data types and
    ioctl definitions can be accessed by including
    <emphasis role="bold">linux/dvb/frontend.h</emphasis> in your application.
</para>

<para>NOTE: Transmission via the internet (DVB-IP)
    is not yet handled by this API but a future extension is possible.</para>
<para>On Satellital systems, the API support for the Satellite Equipment Control
    (SEC) allows to power control and to send/receive signals to control the
    antenna subsystem, selecting the polarization and choosing the Intermediate
    Frequency IF) of the Low Noise Block Converter Feed Horn (LNBf). It
    supports the DiSEqC and V-SEC protocols. The DiSEqC (digital SEC)
specification is available at
<ulink url="http://www.eutelsat.com/satellites/4_5_5.html">Eutelsat</ulink>.</para>


<section id="query-dvb-frontend-info">
<title>Querying frontend information</title>

<para>Information about the frontend ca be queried with
	<link linkend="FE_GET_INFO">FE_GET_INFO</link>.</para>
</section>

<refentry id="FE_GET_INFO">
  <refmeta>
    <refentrytitle>ioctl FE_GET_INFO</refentrytitle>
    &manvol;
  </refmeta>

  <refnamediv>
    <refname>FE_GET_INFO</refname>
    <refpurpose>Query DVB frontend capabilities and returns information about
	the front-end. This call only requires read-only access to the device</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <funcsynopsis>
      <funcprototype>
	<funcdef>int <function>ioctl</function></funcdef>
	<paramdef>int <parameter>fd</parameter></paramdef>
	<paramdef>int <parameter>request</parameter></paramdef>
	<paramdef>struct dvb_frontend_info *<parameter>argp</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Arguments</title>
        <variablelist>
      <varlistentry>
	<term><parameter>fd</parameter></term>
	<listitem>
	  <para>&fd;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><parameter>request</parameter></term>
	<listitem>
	  <para>FE_GET_INFO</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><parameter>argp</parameter></term>
	<listitem>
	    <para>pointer to struct &dvb-frontend-info;</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>Description</title>

    <para>All DVB frontend devices support the
<constant>FE_GET_INFO</constant> ioctl. It is used to identify
kernel devices compatible with this specification and to obtain
information about driver and hardware capabilities. The ioctl takes a
pointer to dvb_frontend_info which is filled by the driver. When the
driver is not compatible with this specification the ioctl returns an error &return-value-dvb;.
</para>

    <table pgwide="1" frame="none" id="dvb-frontend-info">
      <title>struct <structname>dvb_frontend_info</structname></title>
      <tgroup cols="3">
	&cs-str;
	<tbody valign="top">
	  <row>
	    <entry>char *</entry>
	    <entry>name[128]</entry>
	    <entry>Name of the frontend</entry>
	  </row><row>
	    <entry>fe_type_t</entry>
	    <entry>type</entry>
	    <entry>DVBv3 type. Should not be used on modern programs, as a
		frontend may have more than one type. So, the DVBv5 API should
		be used instead to enumerate and select the frontend type.</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>frequency_min</entry>
	    <entry>Minimal frequency supported by the frontend</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>frequency_max</entry>
	    <entry>Maximal frequency supported by the frontend</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>frequency_stepsize</entry>
	    <entry>Frequency step - all frequencies are multiple of this value</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>frequency_tolerance</entry>
	    <entry>Tolerance of the frequency</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>symbol_rate_min</entry>
	    <entry>Minimal symbol rate (for Cable/Satellite systems), in bauds</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>symbol_rate_max</entry>
	    <entry>Maximal symbol rate (for Cable/Satellite systems), in bauds</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>symbol_rate_tolerance</entry>
	    <entry>Maximal symbol rate tolerance, in ppm</entry>
	  </row><row>
	    <entry>uint32_t</entry>
	    <entry>notifier_delay</entry>
	    <entry>Deprecated. Not used by any driver.</entry>
	  </row><row>
	    <entry>&fe-caps;</entry>
	    <entry>caps</entry>
	    <entry>Capabilities supported by the frontend</entry>
          </row>
	</tbody>
      </tgroup>
    </table>
  </refsect1>

  <para>NOTE: The frequencies are specified in Hz for Terrestrial and Cable
      systems. They're specified in kHz for Satellite systems</para>

<section id="fe-caps-t">
<title>frontend capabilities</title>

<para>Capabilities describe what a frontend can do. Some capabilities are
    supported only on some specific frontend types.</para>

<table pgwide="1" frame="none" id="fe-caps">
    <title>enum fe_caps</title>
    <tgroup cols="2">
	&cs-def;
	<thead>
	<row>
	    <entry>ID</entry>
	    <entry>Description</entry>
	</row>
	</thead>
	<tbody valign="top">
	<row>
	<entry><constant>FE_IS_STUPID</constant></entry>
	<entry>There's something wrong at the frontend, and it can't
	    report its capabilities</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_INVERSION_AUTO</constant></entry>
	<entry>The frontend is capable of auto-detecting inversion</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_1_2</constant></entry>
	<entry>The frontend supports FEC 1/2</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_2_3</constant></entry>
	<entry>The frontend supports FEC 2/3</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_3_4</constant></entry>
	<entry>The frontend supports FEC 3/4</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_4_5</constant></entry>
	<entry>The frontend supports FEC 4/5</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_5_6</constant></entry>
	<entry>The frontend supports FEC 5/6</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_6_7</constant></entry>
	<entry>The frontend supports FEC 6/7</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_7_8</constant></entry>
	<entry>The frontend supports FEC 7/8</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_8_9</constant></entry>
	<entry>The frontend supports FEC 8/9</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_FEC_AUTO</constant></entry>
	<entry>The frontend can autodetect FEC.</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QPSK</constant></entry>
	<entry>The frontend supports QPSK modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_16</constant></entry>
	<entry>The frontend supports 16-QAM modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_32</constant></entry>
	<entry>The frontend supports 32-QAM modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_64</constant></entry>
	<entry>The frontend supports 64-QAM modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_128</constant></entry>
	<entry>The frontend supports 128-QAM modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_256</constant></entry>
	<entry>The frontend supports 256-QAM modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_QAM_AUTO</constant></entry>
	<entry>The frontend can autodetect modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_TRANSMISSION_MODE_AUTO</constant></entry>
	<entry>The frontend can autodetect the transmission mode</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_BANDWIDTH_AUTO</constant></entry>
	<entry>The frontend can autodetect the bandwidth</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_GUARD_INTERVAL_AUTO</constant></entry>
	<entry>The frontend can autodetect the guard interval</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_HIERARCHY_AUTO</constant></entry>
	<entry>The frontend can autodetect hierarch</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_8VSB</constant></entry>
	<entry>The frontend supports 8-VSB modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_16VSB</constant></entry>
	<entry>The frontend supports 16-VSB modulation</entry>
	</row>
	<row>
	<entry><constant>FE_HAS_EXTENDED_CAPS</constant></entry>
	<entry>Currently, unused</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_MULTISTREAM</constant></entry>
	<entry>The frontend supports multistream filtering</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_TURBO_FEC</constant></entry>
	<entry>The frontend supports turbo FEC modulation</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_2G_MODULATION</constant></entry>
	<entry>The frontend supports "2nd generation modulation" (DVB-S2/T2)></entry>
	</row>
	<row>
	<entry><constant>FE_NEEDS_BENDING</constant></entry>
	<entry>Not supported anymore, don't use it</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_RECOVER</constant></entry>
	<entry>The frontend can recover from a cable unplug automatically</entry>
	</row>
	<row>
	<entry><constant>FE_CAN_MUTE_TS</constant></entry>
	<entry>The frontend can stop spurious TS data output</entry>
	</row>
        </tbody>
    </tgroup>
</table>
</section>
</refentry>

<section id="dvb-diseqc-master-cmd">
<title>diseqc master command</title>

<para>A message sent from the frontend to DiSEqC capable equipment.</para>
<programlisting>
	struct dvb_diseqc_master_cmd {
	uint8_t msg [6]; /&#x22C6;  { framing, address, command, data[3] } &#x22C6;/
	uint8_t msg_len; /&#x22C6;  valid values are 3...6  &#x22C6;/
	};
</programlisting>
</section>

<section role="subsection" id="dvb-diseqc-slave-reply">
<title>diseqc slave reply</title>

<para>A reply to the frontend from DiSEqC 2.0 capable equipment.</para>
<programlisting>
	struct dvb_diseqc_slave_reply {
	uint8_t msg [4]; /&#x22C6;  { framing, data [3] } &#x22C6;/
	uint8_t msg_len; /&#x22C6;  valid values are 0...4, 0 means no msg  &#x22C6;/
	int     timeout; /&#x22C6;  return from ioctl after timeout ms with &#x22C6;/
	};                       /&#x22C6;  errorcode when no message was received  &#x22C6;/
</programlisting>
</section>

<section id="fe-sec-voltage-t">
<title>diseqc slave reply</title>
<para>The voltage is usually used with non-DiSEqC capable LNBs to switch the polarzation
(horizontal/vertical). When using DiSEqC epuipment this voltage has to be switched
consistently to the DiSEqC commands as described in the DiSEqC spec.</para>
<programlisting>
	typedef enum fe_sec_voltage {
	SEC_VOLTAGE_13,
	SEC_VOLTAGE_18
	} fe_sec_voltage_t;
</programlisting>
</section>

<section id="fe-sec-tone-mode-t">
<title>SEC continuous tone</title>

<para>The continuous 22KHz tone is usually used with non-DiSEqC capable LNBs to switch the
high/low band of a dual-band LNB. When using DiSEqC epuipment this voltage has to
be switched consistently to the DiSEqC commands as described in the DiSEqC
spec.</para>
<programlisting>
	typedef enum fe_sec_tone_mode {
	SEC_TONE_ON,
	SEC_TONE_OFF
	} fe_sec_tone_mode_t;
</programlisting>
</section>

<section id="fe-sec-mini-cmd-t">
<title>SEC tone burst</title>

<para>The 22KHz tone burst is usually used with non-DiSEqC capable switches to select
between two connected LNBs/satellites. When using DiSEqC epuipment this voltage has to
be switched consistently to the DiSEqC commands as described in the DiSEqC
spec.</para>
<programlisting>
	typedef enum fe_sec_mini_cmd {
	SEC_MINI_A,
	SEC_MINI_B
	} fe_sec_mini_cmd_t;
</programlisting>

<para></para>
</section>

<section id="fe-status-t">
<title>frontend status</title>
<para>Several functions of the frontend device use the fe_status data type defined
by</para>
<programlisting>
typedef enum fe_status {
	FE_HAS_SIGNAL		= 0x01,
	FE_HAS_CARRIER		= 0x02,
	FE_HAS_VITERBI		= 0x04,
	FE_HAS_SYNC		= 0x08,
	FE_HAS_LOCK		= 0x10,
	FE_TIMEDOUT		= 0x20,
	FE_REINIT		= 0x40,
} fe_status_t;
</programlisting>
<para>to indicate the current state and/or state changes of the frontend hardware:
</para>

<informaltable><tgroup cols="2"><tbody>
<row>
<entry align="char">FE_HAS_SIGNAL</entry>
<entry align="char">The frontend has found something above the noise level</entry>
</row><row>
<entry align="char">FE_HAS_CARRIER</entry>
<entry align="char">The frontend has found a DVB signal</entry>
</row><row>
<entry align="char">FE_HAS_VITERBI</entry>
<entry align="char">The frontend FEC inner coding (Viterbi, LDPC or other inner code) is stable</entry>
</row><row>
<entry align="char">FE_HAS_SYNC</entry>
<entry align="char">Synchronization bytes was found</entry>
</row><row>
<entry align="char">FE_HAS_LOCK</entry>
<entry align="char">The DVB were locked and everything is working</entry>
</row><row>
<entry align="char">FE_TIMEDOUT</entry>
<entry align="char">no lock within the last about 2 seconds</entry>
</row><row>
<entry align="char">FE_REINIT</entry>
<entry align="char">The frontend was reinitialized, application is
recommended to reset DiSEqC, tone and parameters</entry>
</row>
</tbody></tgroup></informaltable>
</section>

<section id="fe-spectral-inversion-t">
<title>frontend spectral inversion</title>
<para>The Inversion field can take one of these values:
</para>
<programlisting>
typedef enum fe_spectral_inversion {
	INVERSION_OFF,
	INVERSION_ON,
	INVERSION_AUTO
} fe_spectral_inversion_t;
</programlisting>
<para>It indicates if spectral inversion should be presumed or not. In the automatic setting
(<constant>INVERSION_AUTO</constant>) the hardware will try to figure out the correct setting by
itself.
</para>
</section>

<section id="fe-code-rate-t">
<title>frontend code rate</title>
<para>The possible values for the <constant>fec_inner</constant> field used on
<link linkend="dvb-qpsk-parameters"><constant>struct dvb_qpsk_parameters</constant></link> and
<link linkend="dvb-qam-parameters"><constant>struct dvb_qam_parameters</constant></link> are:
</para>
<programlisting>
typedef enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2,
	FEC_2_3,
	FEC_3_4,
	FEC_4_5,
	FEC_5_6,
	FEC_6_7,
	FEC_7_8,
	FEC_8_9,
	FEC_AUTO,
	FEC_3_5,
	FEC_9_10,
} fe_code_rate_t;
</programlisting>
<para>which correspond to error correction rates of 1/2, 2/3, etc., no error correction or auto
detection.
</para>
</section>

<section id="fe-modulation-t">
<title>frontend modulation type for QAM, OFDM and VSB</title>
<para>For cable and terrestrial frontends, e. g. for
<link linkend="dvb-qam-parameters"><constant>struct dvb_qpsk_parameters</constant></link>,
<link linkend="dvb-ofdm-parameters"><constant>struct dvb_qam_parameters</constant></link> and
<link linkend="dvb-vsb-parameters"><constant>struct dvb_qam_parameters</constant></link>,
it needs to specify the quadrature modulation mode which can be one of the following:
</para>
<programlisting>
 typedef enum fe_modulation {
	QPSK,
	QAM_16,
	QAM_32,
	QAM_64,
	QAM_128,
	QAM_256,
	QAM_AUTO,
	VSB_8,
	VSB_16,
	PSK_8,
	APSK_16,
	APSK_32,
	DQPSK,
 } fe_modulation_t;
</programlisting>
</section>

<section>
<title>More OFDM parameters</title>

<section id="fe-transmit-mode-t">
<title>Number of carriers per channel</title>
<programlisting>
typedef enum fe_transmit_mode {
	TRANSMISSION_MODE_2K,
	TRANSMISSION_MODE_8K,
	TRANSMISSION_MODE_AUTO,
	TRANSMISSION_MODE_4K,
	TRANSMISSION_MODE_1K,
	TRANSMISSION_MODE_16K,
	TRANSMISSION_MODE_32K,
 } fe_transmit_mode_t;
</programlisting>
</section>

<section id="fe-bandwidth-t">
<title>frontend bandwidth</title>
<programlisting>
typedef enum fe_bandwidth {
	BANDWIDTH_8_MHZ,
	BANDWIDTH_7_MHZ,
	BANDWIDTH_6_MHZ,
	BANDWIDTH_AUTO,
	BANDWIDTH_5_MHZ,
	BANDWIDTH_10_MHZ,
	BANDWIDTH_1_712_MHZ,
} fe_bandwidth_t;
</programlisting>
</section>

<section id="fe-guard-interval-t">
<title>frontend guard inverval</title>
<programlisting>
typedef enum fe_guard_interval {
	GUARD_INTERVAL_1_32,
	GUARD_INTERVAL_1_16,
	GUARD_INTERVAL_1_8,
	GUARD_INTERVAL_1_4,
	GUARD_INTERVAL_AUTO,
	GUARD_INTERVAL_1_128,
	GUARD_INTERVAL_19_128,
	GUARD_INTERVAL_19_256,
} fe_guard_interval_t;
</programlisting>
</section>

<section id="fe-hierarchy-t">
<title>frontend hierarchy</title>
<programlisting>
typedef enum fe_hierarchy {
	 HIERARCHY_NONE,
	 HIERARCHY_1,
	 HIERARCHY_2,
	 HIERARCHY_4,
	 HIERARCHY_AUTO
 } fe_hierarchy_t;
</programlisting>
</section>

</section>

<section id="frontend_fcalls">
<title>Frontend Function Calls</title>

<section id="frontend_f_open">
<title>open()</title>
<para>DESCRIPTION</para>
<informaltable><tgroup cols="1"><tbody><row>
<entry align="char">
<para>This system call opens a named frontend device (/dev/dvb/adapter0/frontend0)
 for subsequent use. Usually the first thing to do after a successful open is to
 find out the frontend type with <link linkend="FE_GET_INFO">FE_GET_INFO</link>.</para>
<para>The device can be opened in read-only mode, which only allows monitoring of
 device status and statistics, or read/write mode, which allows any kind of use
 (e.g. performing tuning operations.)
</para>
<para>In a system with multiple front-ends, it is usually the case that multiple devices
 cannot be open in read/write mode simultaneously. As long as a front-end
 device is opened in read/write mode, other open() calls in read/write mode will
 either fail or block, depending on whether non-blocking or blocking mode was
 specified. A front-end device opened in blocking mode can later be put into
 non-blocking mode (and vice versa) using the F_SETFL command of the fcntl
 system call. This is a standard system call, documented in the Linux manual
 page for fcntl. When an open() call has succeeded, the device will be ready
 for use in the specified mode. This implies that the corresponding hardware is
 powered up, and that other front-ends may have been powered down to make
 that possible.</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>SYNOPSIS</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int open(const char &#x22C6;deviceName, int flags);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>const char
 *deviceName</para>
</entry><entry
 align="char">
<para>Name of specific video device.</para>
</entry>
 </row><row><entry
 align="char">
<para>int flags</para>
</entry><entry
 align="char">
<para>A bit-wise OR of the following flags:</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>O_RDONLY read-only access</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>O_RDWR read/write access</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>O_NONBLOCK open in non-blocking mode</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>(blocking mode is the default)</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>ENODEV</para>
</entry><entry
 align="char">
<para>Device driver not loaded/available.</para>
</entry>
 </row><row><entry
 align="char">
<para>EINTERNAL</para>
</entry><entry
 align="char">
<para>Internal error.</para>
</entry>
 </row><row><entry
 align="char">
<para>EBUSY</para>
</entry><entry
 align="char">
<para>Device or resource busy.</para>
</entry>
 </row><row><entry
 align="char">
<para>EINVAL</para>
</entry><entry
 align="char">
<para>Invalid argument.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="frontend_f_close">
<title>close()</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This system call closes a previously opened front-end device. After closing
 a front-end device, its corresponding hardware might be powered down
 automatically.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int close(int fd);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EBADF</para>
</entry><entry
 align="char">
<para>fd is not a valid open file descriptor.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="FE_READ_STATUS">
<title>FE_READ_STATUS</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call returns status information about the front-end. This call only
 requires read-only access to the device.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request = <link linkend="FE_READ_STATUS">FE_READ_STATUS</link>,
 fe_status_t &#x22C6;status);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>

<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_READ_STATUS">FE_READ_STATUS</link> for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct fe_status_t
 *status</para>
</entry><entry
 align="char">
<para>Points to the location where the front-end status word is
 to be stored.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EBADF</para>
</entry><entry
 align="char">
<para>fd is not a valid open file descriptor.</para>
</entry>
 </row><row><entry
 align="char">
<para>EFAULT</para>
</entry><entry
 align="char">
<para>status points to invalid address.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>


<section id="FE_DISEQC_RESET_OVERLOAD">
<title>FE_DISEQC_RESET_OVERLOAD</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>If the bus has been automatically powered off due to power overload, this ioctl
 call restores the power to the bus. The call requires read/write access to the
 device. This call has no effect if the device is manually powered off. Not all
 DVB adapters support this ioctl.</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request =
 <link linkend="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</link>);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</link> for this
 command.</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

<section id="FE_DISEQC_SEND_MASTER_CMD">
<title>FE_DISEQC_SEND_MASTER_CMD</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to send a a DiSEqC command.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request =
 <link linkend="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</link>, struct
 dvb_diseqc_master_cmd &#x22C6;cmd);</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</link> for this
 command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct
 dvb_diseqc_master_cmd
 *cmd</para>
</entry><entry
 align="char">
<para>Pointer to the command to be transmitted.</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

<section id="FE_DISEQC_RECV_SLAVE_REPLY">
<title>FE_DISEQC_RECV_SLAVE_REPLY</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to receive reply to a DiSEqC 2.0 command.</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request =
 <link linkend="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</link>, struct
 dvb_diseqc_slave_reply &#x22C6;reply);</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</link> for this
 command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct
 dvb_diseqc_slave_reply
 *reply</para>
</entry><entry
 align="char">
<para>Pointer to the command to be received.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="FE_DISEQC_SEND_BURST">
<title>FE_DISEQC_SEND_BURST</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to send a 22KHz tone burst.</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request =
 <link linkend="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</link>, fe_sec_mini_cmd_t burst);</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</link> for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>fe_sec_mini_cmd_t
 burst</para>
</entry><entry
 align="char">
<para>burst A or B.</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

<section id="FE_SET_TONE">
<title>FE_SET_TONE</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This call is used to set the generation of the continuous 22kHz tone. This call
 requires read/write permissions.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request = <link linkend="FE_SET_TONE">FE_SET_TONE</link>,
 fe_sec_tone_mode_t tone);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_SET_TONE">FE_SET_TONE</link> for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>fe_sec_tone_mode_t
 tone</para>
</entry><entry
 align="char">
<para>The requested tone generation mode (on/off).</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="FE_SET_VOLTAGE">
<title>FE_SET_VOLTAGE</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This call is used to set the bus voltage. This call requires read/write
 permissions.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request = <link linkend="FE_SET_VOLTAGE">FE_SET_VOLTAGE</link>,
 fe_sec_voltage_t voltage);</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_SET_VOLTAGE">FE_SET_VOLTAGE</link> for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>fe_sec_voltage_t
 voltage</para>
</entry><entry
 align="char">
<para>The requested bus voltage.</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

<section id="FE_ENABLE_HIGH_LNB_VOLTAGE">
<title>FE_ENABLE_HIGH_LNB_VOLTAGE</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>If high != 0 enables slightly higher voltages instead of 13/18V (to compensate
 for long cables). This call requires read/write permissions. Not all DVB
 adapters support this ioctl.</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl(int fd, int request =
 <link linkend="FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</link>, int high);</para>
</entry>
 </row></tbody></tgroup></informaltable>

<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals <link linkend="FE_SET_VOLTAGE">FE_SET_VOLTAGE</link> for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>int high</para>
</entry><entry
 align="char">
<para>The requested bus voltage.</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

<section id="FE_SET_FRONTEND_TUNE_MODE">
<title>FE_SET_FRONTEND_TUNE_MODE</title>
<para>DESCRIPTION</para>
<informaltable><tgroup cols="1"><tbody><row>
<entry align="char">
<para>Allow setting tuner mode flags to the frontend.</para>
</entry>
</row></tbody></tgroup></informaltable>

<para>SYNOPSIS</para>
<informaltable><tgroup cols="1"><tbody><row>
<entry align="char">
<para>int ioctl(int fd, int request =
<link linkend="FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</link>, unsigned int flags);</para>
</entry>
</row></tbody></tgroup></informaltable>

<para>PARAMETERS</para>
<informaltable><tgroup cols="2"><tbody><row>
<entry align="char">
	<para>unsigned int flags</para>
</entry>
<entry align="char">
<para>
FE_TUNE_MODE_ONESHOT When set, this flag will disable any zigzagging or other "normal" tuning behaviour. Additionally, there will be no automatic monitoring of the lock status, and hence no frontend events will be generated. If a frontend device is closed, this flag will be automatically turned off when the device is reopened read-write.
</para>
</entry>
 </row></tbody></tgroup></informaltable>

&return-value-dvb;
</section>

</section>

<section id="frontend_legacy_dvbv3_api">
<title>DVB Frontend legacy API (a. k. a. DVBv3)</title>
<para>The usage of this API is deprecated, as it doesn't support all digital
    TV standards, doesn't provide good statistics measurements and provides
    incomplete information. This is kept only to support legacy applications.</para>

&sub-frontend_legacy_api;
</section>

&sub-dvbproperty;
