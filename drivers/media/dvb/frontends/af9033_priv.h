/*
 * Afatech AF9033 demodulator driver
 *
 * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
 * Copyright (C) 2012 Antti Palosaari <crope@iki.fi>
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License along
 *    with this program; if not, write to the Free Software Foundation, Inc.,
 *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef AF9033_PRIV_H
#define AF9033_PRIV_H

#include "dvb_frontend.h"
#include "af9033.h"

struct reg_val {
	u32 reg;
	u8  val;
};

struct reg_val_mask {
	u32 reg;
	u8  val;
	u8  mask;
};

struct coeff {
	u32 clock;
	u32 bandwidth_hz;
	u8 val[36];
};

struct clock_adc {
	u32 clock;
	u32 adc;
};

/* Xtal clock vs. ADC clock lookup table */
static const struct clock_adc clock_adc_lut[] = {
	{ 16384000, 20480000 },
	{ 20480000, 20480000 },
	{ 36000000, 20250000 },
	{ 30000000, 20156250 },
	{ 26000000, 20583333 },
	{ 28000000, 20416667 },
	{ 32000000, 20500000 },
	{ 34000000, 20187500 },
	{ 24000000, 20500000 },
	{ 22000000, 20625000 },
	{ 12000000, 20250000 },
};

/* pre-calculated coeff lookup table */
static const struct coeff coeff_lut[] = {
	/* 12.000 MHz */
	{ 12000000, 8000000, {
		0x01, 0xce, 0x55, 0xc9, 0x00, 0xe7, 0x2a, 0xe4, 0x00, 0x73,
		0x99, 0x0f, 0x00, 0x73, 0x95, 0x72, 0x00, 0x73, 0x91, 0xd5,
		0x00, 0x39, 0xca, 0xb9, 0x00, 0xe7, 0x2a, 0xe4, 0x00, 0x73,
		0x95, 0x72, 0x37, 0x02, 0xce, 0x01 }
	},
	{ 12000000, 7000000, {
		0x01, 0x94, 0x8b, 0x10, 0x00, 0xca, 0x45, 0x88, 0x00, 0x65,
		0x25, 0xed, 0x00, 0x65, 0x22, 0xc4, 0x00, 0x65, 0x1f, 0x9b,
		0x00, 0x32, 0x91, 0x62, 0x00, 0xca, 0x45, 0x88, 0x00, 0x65,
		0x22, 0xc4, 0x88, 0x02, 0x95, 0x01 }
	},
	{ 12000000, 6000000, {
		0x01, 0x5a, 0xc0, 0x56, 0x00, 0xad, 0x60, 0x2b, 0x00, 0x56,
		0xb2, 0xcb, 0x00, 0x56, 0xb0, 0x15, 0x00, 0x56, 0xad, 0x60,
		0x00, 0x2b, 0x58, 0x0b, 0x00, 0xad, 0x60, 0x2b, 0x00, 0x56,
		0xb0, 0x15, 0xf4, 0x02, 0x5b, 0x01 }
	},
};

static const struct reg_val ofsm_init[] = {
	{ 0x800051, 0x01 },
	{ 0x800070, 0x0a },
	{ 0x80007e, 0x04 },
	{ 0x800081, 0x0a },
	{ 0x80008a, 0x01 },
	{ 0x80008e, 0x01 },
	{ 0x800092, 0x06 },
	{ 0x800099, 0x01 },
	{ 0x80009f, 0xe1 },
	{ 0x8000a0, 0xcf },
	{ 0x8000a3, 0x01 },
	{ 0x8000a5, 0x01 },
	{ 0x8000a6, 0x01 },
	{ 0x8000a9, 0x00 },
	{ 0x8000aa, 0x01 },
	{ 0x8000ab, 0x01 },
	{ 0x8000b0, 0x01 },
	{ 0x8000c0, 0x05 },
	{ 0x8000c4, 0x19 },
	{ 0x80f000, 0x0f },
	{ 0x80f016, 0x10 },
	{ 0x80f017, 0x04 },
	{ 0x80f018, 0x05 },
	{ 0x80f019, 0x04 },
	{ 0x80f01a, 0x05 },
	{ 0x80f021, 0x03 },
	{ 0x80f022, 0x0a },
	{ 0x80f023, 0x0a },
	{ 0x80f02b, 0x00 },
	{ 0x80f02c, 0x01 },
	{ 0x80f064, 0x03 },
	{ 0x80f065, 0xf9 },
	{ 0x80f066, 0x03 },
	{ 0x80f067, 0x01 },
	{ 0x80f06f, 0xe0 },
	{ 0x80f070, 0x03 },
	{ 0x80f072, 0x0f },
	{ 0x80f073, 0x03 },
	{ 0x80f078, 0x00 },
	{ 0x80f087, 0x00 },
	{ 0x80f09b, 0x3f },
	{ 0x80f09c, 0x00 },
	{ 0x80f09d, 0x20 },
	{ 0x80f09e, 0x00 },
	{ 0x80f09f, 0x0c },
	{ 0x80f0a0, 0x00 },
	{ 0x80f130, 0x04 },
	{ 0x80f132, 0x04 },
	{ 0x80f144, 0x1a },
	{ 0x80f146, 0x00 },
	{ 0x80f14a, 0x01 },
	{ 0x80f14c, 0x00 },
	{ 0x80f14d, 0x00 },
	{ 0x80f14f, 0x04 },
	{ 0x80f158, 0x7f },
	{ 0x80f15a, 0x00 },
	{ 0x80f15b, 0x08 },
	{ 0x80f15d, 0x03 },
	{ 0x80f15e, 0x05 },
	{ 0x80f163, 0x05 },
	{ 0x80f166, 0x01 },
	{ 0x80f167, 0x40 },
	{ 0x80f168, 0x0f },
	{ 0x80f17a, 0x00 },
	{ 0x80f17b, 0x00 },
	{ 0x80f183, 0x01 },
	{ 0x80f19d, 0x40 },
	{ 0x80f1bc, 0x36 },
	{ 0x80f1bd, 0x00 },
	{ 0x80f1cb, 0xa0 },
	{ 0x80f1cc, 0x01 },
	{ 0x80f204, 0x10 },
	{ 0x80f214, 0x00 },
	{ 0x80f40e, 0x0a },
	{ 0x80f40f, 0x40 },
	{ 0x80f410, 0x08 },
	{ 0x80f55f, 0x0a },
	{ 0x80f561, 0x15 },
	{ 0x80f562, 0x20 },
	{ 0x80f5df, 0xfb },
	{ 0x80f5e0, 0x00 },
	{ 0x80f5e3, 0x09 },
	{ 0x80f5e4, 0x01 },
	{ 0x80f5e5, 0x01 },
	{ 0x80f5f8, 0x01 },
	{ 0x80f5fd, 0x01 },
	{ 0x80f600, 0x05 },
	{ 0x80f601, 0x08 },
	{ 0x80f602, 0x0b },
	{ 0x80f603, 0x0e },
	{ 0x80f604, 0x11 },
	{ 0x80f605, 0x14 },
	{ 0x80f606, 0x17 },
	{ 0x80f607, 0x1f },
	{ 0x80f60e, 0x00 },
	{ 0x80f60f, 0x04 },
	{ 0x80f610, 0x32 },
	{ 0x80f611, 0x10 },
	{ 0x80f707, 0xfc },
	{ 0x80f708, 0x00 },
	{ 0x80f709, 0x37 },
	{ 0x80f70a, 0x00 },
	{ 0x80f78b, 0x01 },
	{ 0x80f80f, 0x40 },
	{ 0x80f810, 0x54 },
	{ 0x80f811, 0x5a },
	{ 0x80f905, 0x01 },
	{ 0x80fb06, 0x03 },
	{ 0x80fd8b, 0x00 },
};

/* Infineon TUA 9001 tuner init
   AF9033_TUNER_TUA9001    = 0x27 */
static const struct reg_val tuner_init_tua9001[] = {
	{ 0x800046, 0x27 },
	{ 0x800057, 0x00 },
	{ 0x800058, 0x01 },
	{ 0x80005f, 0x00 },
	{ 0x800060, 0x00 },
	{ 0x80006d, 0x00 },
	{ 0x800071, 0x05 },
	{ 0x800072, 0x02 },
	{ 0x800074, 0x01 },
	{ 0x800075, 0x03 },
	{ 0x800076, 0x02 },
	{ 0x800077, 0x00 },
	{ 0x800078, 0x01 },
	{ 0x800079, 0x00 },
	{ 0x80007a, 0x7e },
	{ 0x80007b, 0x3e },
	{ 0x800093, 0x00 },
	{ 0x800094, 0x01 },
	{ 0x800095, 0x02 },
	{ 0x800096, 0x01 },
	{ 0x800098, 0x0a },
	{ 0x80009b, 0x05 },
	{ 0x80009c, 0x80 },
	{ 0x8000b3, 0x00 },
	{ 0x8000c1, 0x01 },
	{ 0x8000c2, 0x00 },
	{ 0x80f007, 0x00 },
	{ 0x80f01f, 0x82 },
	{ 0x80f020, 0x00 },
	{ 0x80f029, 0x82 },
	{ 0x80f02a, 0x00 },
	{ 0x80f047, 0x00 },
	{ 0x80f054, 0x00 },
	{ 0x80f055, 0x00 },
	{ 0x80f077, 0x01 },
	{ 0x80f1e6, 0x00 },
};

#endif /* AF9033_PRIV_H */

