// SPDX-License-Identifier: GPL-2.0 OR X11
/*
 * Copyright 2017 (C) Priit Laes <plaes@plaes.org>
 * Copyright 2018 (C) Pengutronix, Michael Grzeschik <mgr@pengutronix.de>
 * Copyright 2019 (C) Pengutronix, Marco Felsch <kernel@pengutronix.de>
 *
 * Based on initial work by Nikita Yushchenko <nyushchenko at dev.rtsoft.ru>
 */

#include <dt-bindings/gpio/gpio.h>

/ {
	reg_1p0v_s0: regulator-1p0v-s0 {
		compatible = "regulator-fixed";
		regulator-name = "V_1V0_S0";
		regulator-min-microvolt = <1000000>;
		regulator-max-microvolt = <1000000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_smarc_suppy>;
	};

	reg_1p35v_vcoredig_s5: regulator-1p35v-vcoredig-s5 {
		compatible = "regulator-fixed";
		regulator-name = "V_1V35_VCOREDIG_S5";
		regulator-min-microvolt = <1350000>;
		regulator-max-microvolt = <1350000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_3p3v_s5>;
	};

	reg_1p8v_s5: regulator-1p8v-s5 {
		compatible = "regulator-fixed";
		regulator-name = "V_1V8_S5";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_3p3v_s5>;
	};

	reg_3p3v_s0: regulator-3p3v-s0 {
		compatible = "regulator-fixed";
		regulator-name = "V_3V3_S0";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_3p3v_s5>;
	};

	reg_3p3v_s0: regulator-3p3v-s0 {
		compatible = "regulator-fixed";
		regulator-name = "V_3V3_S0";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_3p3v_s5>;
	};

	reg_3p3v_s5: regulator-3p3v-s5 {
		compatible = "regulator-fixed";
		regulator-name = "V_3V3_S5";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		regulator-boot-on;
		vin-supply = <&reg_smarc_suppy>;
	};

	reg_smarc_rtc: regulator-smarc-rtc {
		compatible = "regulator-fixed";
		regulator-name = "V_IN_RTC_BATT";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		regulator-boot-on;
	};

	/* Module supply range can be 3.00V ... 5.25V */
	reg_smarc_suppy: regulator-smarc-supply {
		compatible = "regulator-fixed";
		regulator-name = "V_IN_WIDE";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
		regulator-boot-on;
	};

	i2c_intern: i2c-gpio-intern {
		compatible = "i2c-gpio";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2c_gpio_intern>;
		sda-gpios = <&gpio1 28 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		scl-gpios = <&gpio1 30 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		i2c-gpio,delay-us = <2>; /* ~100 kHz */
		#address-cells = <1>;
		#size-cells = <0>;
	};
};

/* CAN0 */
&can1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan1>;
};

/* CAN1 */
&can2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan2>;
};

/* GBE */
&fec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet>;
	phy-mode = "rgmii";
	phy-reset-gpios = <&gpio1 25 GPIO_ACTIVE_LOW>;
};

&i2c_intern {
	pmic@8 {
		compatible = "fsl,pfuze100";
		reg = <0x08>;

		regulators {
			reg_v_core_s0: sw1ab {
				regulator-name = "V_CORE_S0";
				regulator-min-microvolt = <300000>;
				regulator-max-microvolt = <1875000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_vddsoc_s0: sw1c {
				regulator-name = "V_VDDSOC_S0";
				regulator-min-microvolt = <300000>;
				regulator-max-microvolt = <1875000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_3p15v_s0: sw2 {
				regulator-name = "V_3V15_S0";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			/* sw3a/b is used in dual mode, but driver does not
			 * support it. Although, there's no need to control
			 * DDR power - so just leaving dummy entries for sw3a
			 * and sw3b for now.
			 */
			sw3a {
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1975000>;
				regulator-boot-on;
				regulator-always-on;
			};

			sw3b {
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1975000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_1p8v_s0: sw4 {
				regulator-name = "V_1V8_S0";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			/* Regulator for USB */
			reg_5p0v_s0: swbst {
				regulator-name = "V_5V0_S0";
				regulator-min-microvolt = <5000000>;
				regulator-max-microvolt = <5150000>;
				regulator-boot-on;
			};

			reg_vsnvs: vsnvs {
				regulator-min-microvolt = <1000000>;
				regulator-max-microvolt = <3000000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_vrefddr: vrefddr {
				regulator-boot-on;
				regulator-always-on;
			};

			/*
			 * Per schematics, of all VGEN's, only VGEN5 has some
			 * usage ... but even that - over DNI resistor
			 */
			vgen1 {
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1550000>;
			};

			vgen2 {
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1550000>;
			};

			vgen3 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			vgen4 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			reg_2p5v_s0: vgen5 {
				regulator-name = "V_2V5_S0";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			vgen6 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};
		};
	};
};

/* I2C_PM */
&i2c3 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c3>;
};

&iomuxc {
	pinctrl_flexcan1: flexcan1grp {
		fsl,pins = <
			MX6QDL_PAD_GPIO_7__FLEXCAN1_TX 0x1b0b0
			MX6QDL_PAD_GPIO_8__FLEXCAN1_RX 0x1b0b0
		>;
	};

	pinctrl_flexcan2: flexcan2grp {
		fsl,pins = <
			MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX 0x1b0b0
			MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX 0x1b0b0
		>;
	};

	pinctrl_enet: enetgrp {
		fsl,pins = <
			MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
			MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
			MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
			MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
			MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
			MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
			MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
			MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
			MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
			MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
			MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
			MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0

			MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
			MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
			MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
			MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25    0x1b0b0 /* RST_GBE0_PHY# */
		>;
	};

	pinctrl_i2c_gpio_intern: i2c-gpiointerngrp {
		fsl,pins = <
			MX6QDL_PAD_ENET_TXD0__GPIO1_IO30  0x1b0b0 /* SCL */
			MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28 0x1b0b0 /* SDA */
		>;
	};

	pinctrl_i2c3: i2c3grp {
		fsl,pins = <
			MX6QDL_PAD_GPIO_3__I2C3_SCL		0x4001b8b1
			MX6QDL_PAD_GPIO_16__I2C3_SDA		0x4001b8b1
		>;
	};

	pinctrl_pcie: pciegrp {
		fsl,pins = <
			MX6QDL_PAD_EIM_D18__GPIO3_IO18	0x1b0b0 /* PCI_A_PRSNT# */
			MX6QDL_PAD_EIM_DA13__GPIO3_IO13 0x1b0b0 /* RST_PCIE_A#  */
			MX6QDL_PAD_SD3_DAT6__GPIO6_IO18 0x1b0b0 /* PCIE_WAKE#   */
		>;
	};

	pinctrl_uart1: uart1grp {
		fsl,pins = <
			MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
			MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
			MX6QDL_PAD_EIM_D20__UART1_RTS_B 0x1b0b1
			MX6QDL_PAD_EIM_D19__UART1_CTS_B 0x1b0b1
		>;
	};

	pinctrl_uart2: uart2grp {
		fsl,pins = <
			MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
			MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
		>;
	};

	pinctrl_uart4: uart4grp {
		fsl,pins = <
			MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA 0x1b0b1
			MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA 0x1b0b1
			MX6QDL_PAD_CSI0_DAT16__UART4_RTS_B 0x1b0b1
			MX6QDL_PAD_CSI0_DAT17__UART4_CTS_B 0x1b0b1
		>;
	};

	pinctrl_uart5: uart5grp {
		fsl,pins = <
			MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA 0x1b0b1
			MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA 0x1b0b1
		>;
	};

	pinctrl_usbotg: usbotggrp {
		fsl,pins = <
			MX6QDL_PAD_GPIO_1__USB_OTG_ID 0x1f8b0
			/* power, oc muxed but not used by the driver */
			MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18	0x1b0b0 /* USB power */
			MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20	0x1b0b0 /* USB OC */
		>;
	};

	pinctrl_usdhc4: usdhc4grp {
		fsl,pins = <
			MX6QDL_PAD_SD4_CLK__SD4_CLK 0x17059
			MX6QDL_PAD_SD4_CMD__SD4_CMD 0x17059
			MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059
			MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059
			MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059
			MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059
			MX6QDL_PAD_SD4_DAT4__SD4_DATA4 0x17059
			MX6QDL_PAD_SD4_DAT5__SD4_DATA5 0x17059
			MX6QDL_PAD_SD4_DAT6__SD4_DATA6 0x17059
			MX6QDL_PAD_SD4_DAT7__SD4_DATA7 0x17059
		>;
	};
};

&pcie {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pcie>;
	wake-up-gpio = <&gpio6 18 GPIO_ACTIVE_HIGH>;
	reset-gpio = <&gpio3 13 GPIO_ACTIVE_HIGH>;
};

/* SER0 */
&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1>;
	uart-has-rtscts;
};

/* SER1 */
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2>;
};

/* SER2 */
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart4>;
	uart-has-rtscts;
};

/* SER3 */
&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart5>;
};

/* USB0 */
&usbotg {
	/*
	 * no 'imx6-usb-charger-detection'
	 * since USB_OTG_CHD_B pin is not wired
	 */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbotg>;
};

/* USB1/2 via hub */
&usbh1 {
	vbus-supply = <&reg_5p0v_s0>;
};

/* SDMMC */
&usdhc4 {
	/* Internal eMMC, optional on some boards */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc4>;
	bus-width = <8>;
	no-sdio;
	no-sd;
	non-removable;
	vmmc-supply = <&reg_3p3v_s0>;
	vqmmc-supply = <&reg_1p8v_s0>;
};
